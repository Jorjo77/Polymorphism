using System;
using System.Collections.Generic;

namespace Polymorphism
{
    class Program
    {
        static void Main(string[] args)
        {
            Polymorphism - ability of an object to take on many forms(може да бъде от типа на всички които го наслеяват). Пример:
            Polymorphism е един и същи обект да прави различни неща
            Polymorphism ни помага програмата ни да е по лека, по четима!
           Polymorphism има навсякъде в ООП -то, всички дженерик неща са полиморфизъм.
            От ляво слагаме(работим с) базовия клас/ интерфейс и това е типа на променливата, а отдясно може да бъдат всички наследници на базовия клас / интерфейс - a и това е заделената памет(тя е различна взависимост от наследника)! Така много лесно може да се променя функционалността!
               Със Polymorphism(с различен инпут, baseClass.Area() прави различни неща)
            Дженериците са перфектен Polymorphism
            Използвайки полиморфизъм можем много лесно да екстендваме програмата си!
            Мощтта на полиморфизма и ООП - то е когато искаме да направим по сложна, да екстендваме програмата си!Например: Правим си нов клас dog, наследяваме Animal и той вече си работи с Human - a, вече Human -a може да храни кучета, той работи абстрактно!
            //abstract метод може да има само в абстракт клас и няма имплементация. Виртуал метода е във нормален (неабстрактен клас) и има имплементаця. После и двата метода се оверрайдват в класовете наследници!   
            //ключовата дума is проверява типа на обекта, демо в Animals!
            // С is можем да проверяваме и дали променлива или израз са равни на константа. Пример: if(i is max) break; , но няма голям смисъл, тъй като обикновенно си слагаме = !!!!!!!!
            //Ако ни се наложи много да използваме is (да проверяваме кой кой е) това заначи че нещо кода ни не е добе, това не е добър полиморфиъм! Може да ни се струва че това ни решава проблемите, но не е така, това ни прави проблемите! Това се прави така в кайни случаи - когато тестваме нещо или ако другите го правт така - в общи лини това се счита за лоша практика (проверките кой кой е в Animals за IsKeyword) - така губим целия полиморфизъм!
            //if (typeof(Snake) == snake.GetType()) това прави същото като is, но с is  е по лесно! snake.GetType() е рефлекшън! 
            //{
            //    Console.WriteLine("Stana");
            //}


            Ако ни трябва някой конкретен метод можем да кастнем.
            as е ключова думичка за кастване
            В Program показваме как с помощта на Is можем да кастнем shape към Rectangle!
            Можем да вземем пропъртитата на конкретен обект като го кастнем! Пример за кастване:
            //((Snake)Pet)
            //(Pet as Snake)
            Разликата между двата вида кастване е че при кастването с as ако не успее да кастне ще върне null, а другото гърми!!!!! Затова с as се използва по-често(с проверка за null).
            Кастването е добре да се ползва единично, да не се получава каскада(поредица) от каствания!Каскадата(поредицата) от каствания се избягва като във всеки клас оверрайднем нужния ни метод, т.е.метода ще работи различно според класа и отвън вместо да правим проверки кой кой е, просто извикваме метода!!! Това е полиморфизма, според това къде(в кой клас) се извиква метода, той си има съответното специфично(различно) поведение, поведението зависи от типа в дясно(ot Animal, Mamal или Person), не от типа в ляво:
            !!!   public class Person : Mammal, IAnimal { }
        // var list = new List<Animal>();
        //    object obj = new Person();
        //    IAnimal animal = new Animal();
        //    IAnimal animal = new Mamal();
        //    IAnimal animal = new Person();
        //Поведението на обекта зависи от заделената за него памет - от дясно. 
        //foreach (var item in list)
        //{
        Console.WriteLine(item.GetType());Така ни дава какъв тип е обекта
        item.PrintToConsole(); този метод е с различно поведение според обекта!
            //}
            Заключение: Типа данни от ляво казва какви методи ще мога да викам, а според това какво е от дясно се извиква конкретно неговия метод.Проверява се рън тайм типа (от дясно), взима се неговия метод и той се изпълнява!

           Console.WriteLine(new string ('-', 60)); !// така мога да напиша 60 титета (като разделител)
            Когато имам базов клас с някактв метод дето надолу наследниците ще си оверрайдват, нямам нужда от интерфейс, интерфейси не се пишат задължително върху всеки клас, пишат се при нужда, например ако искаме да намерим нещо общо между класове които нямат общо по между си, например куче и триъгълник, но в контекста на моята програма може общото да е че искам да ги принтирам и тогава с един интерфейс IPrintable който да наследят мога да ги обединя(в една колекция например) за принтиране.Или ако за мен е важен само един метод от йерархията мога с интерфейс да използвам само него.Когатпо някои обекти споделят обши методи те трябва да си имат интерфейс, но не е задължително всеки клас да си има.
           Добра практика също е ако имаме някаква по-голяма логика (например за изчисляване на обем на тези животни) независимо че всички в йерархият ще я използват да не я слагам в базовия клас а във външен отделен и който му трябва да си го инзтанцира и използва!!! Това понякога се прави на етап рефакториране, в повечето случаи когато правиш нещо гледаш да заработи, но после виждаш възможностите за подобрение в кода и го опримизираш(първоначално може да е било в базовия клас и в последствие да решиш че е по-дибре да е самостоятелна единица). Подобряването на качеството и правилния дизайн на класовете е безкраен процес, може и след години да се наложи да рефакторираш нещо.
          Избягваме статични неща, дори един клас да прави само едно нещо (да има само един метод) по-добре е да го направим инстанционен, защото утре можеш да решиш да му сложиш интерфейс, да работиш през интерфейса, да направиш нова имплементация на този клас и да работиш с двете.Много по-гъвкав си когато не използваш нещо статично, много повече са ти опциите.Избягваме ги и ще си спестим доста бъдещи проблеми (статичните класове, Math.и Console са ОК)!!!
            
Когато направим един метод да приема като параметър нещо базово, той става много универсален метод, защото ще може да работи и с всички наследници!!! Това също е полиморфизъм!

Var pattern е леко глезотийка, но идеята му е при по-сложни лампда изрази да подобри четимостта на кода.В случая в ифа винаги е тру и ще запише израза expr на променлива с име varname, която можем да ползваме надолу! (В Мемоус2 е примера )

parshal - рядко се ползва и е ако искаме да направим един клас на 2 файла(обикновено го прави базата данни или VS -а, не ние).

 tortoseGit ползва Ники Костов и смята че е доста удобно(пести му време, по удобно е от чистия гит през конзолата) Аз съм на ГитХъб(на съвсем аматьорско ниво) и не знам същото ли е!?

            Оператора?. е новост и :
            //person?.GetSalary(); е еквивалентно на:
            //if (persin != null)
            //{
            //    person.GetSalary();
            //}
            //въпрос на стил е и се използва!

            Оператора ?? - означава "ако това от ляво е null да се изпълни това от дясно" !!!
            //Пример: Person person = new animal as Person ?? new Person(); Ако енимал е пърсън конвертира енимал към пърсан, но ако енимал не е пърсън връща null и new Person(); ще се изпълни!!! и така никога няма да имам null тук (или енимал ще се конвертира към пърсън или ще се създаде нов пърсън)!!! В бази данни и уеб ще имаме доста null - ове и тези оператори ще се използват!

            //В конструктор да не извикваме виртуални и абстрактни неща!

            //При оверрайдване трябва да спазвам сигнатурата (списъка с параметри) и връщяния тип на метода, не мога да ги променям!

            //Статичен метод не може да бъде виртуал и не може да се оверрайдва (и не е добре да се ползва като цяло).

            //Когато оверрайдваме виртуален метод можем да използваме base за да вземем поведението от базовия метод и да го използваме за нашия оверрайд (добра практика е)!!!

            //Ако напишем seald на виртуален метод в оверрайда, то всички наследници след ТОЗИ ОВЕРРАЙД няма да могат повече да оверрайдват метода и ще получат този метод със seald.

            //Да оверрайдваме метод, да не използваме new с метод със същото име (така този метод скрива виртуалния базов метод), така унищожаваме полиморфизма!!!(тук с new казваме на С# знам че правя глупости, не ме поправяй) Няма сценарий в който new -то да е оправдано!

            //Ред за извикване на конструкторите (от object на долу през всеки наследник). В случай на йерархия Animal->Mamal->Person при създаване на Person() извикването на неговия конструктор е 4-то по ред, а при извикване на метод, например ToString() ще се извика първо ToString() на Person, но ако той казва base.ToString() ще се извика ToString() на Mamal защото той е неговия base, а ако Mamal казва base.ToString() ще се извика ToString() на Animal и ако той казва  base.ToString() ще се извика ToString() на object. С ToString() се качва до първия който има поведение различно от нашето (ако Mamal няма записано поведение на ToString() ще отиде до Animal ако той има) 
(В Мемоус2 е примера )

            //Ще учим Солид принципите, които ни казват да не правим тайп чек!

Type mathing pattern:
             is също така се използва за Type pattern mathing, показан в примера:
            //public class Person : Mammal, IAnimal { }
            //Mammal personOne = new Person();
            //Person personTwo = new Person();
            //if (personTwo is Person person) - Ако personTwo is Person направи променлива от тип Person - person и долу в if -а я използвам, тя съществува само в if -а и в него я ползвам!!!
            //{
            //  person.GetSalary();
            //}

        // !!!   public class Person : Mammal, IAnimal { }
        //    object obj = new Person();
        //    IAnimal animal = new Person();
        //    Mammal mamal = new Person();
        //    Person person = new Person();
        //В различен контекст Person може да бъде obj, animal, mamal и person, но obj има само методите на object, animal на animal и object, mamal на object, animal и mamal, а person на object, animal, mamal и person (това е полиморфизма)!!!

        //Ako ги сложа в лист от IAnimal и после форийчна колекцията ще имам само нещата (методи и пропъртита) на IAnimal, това е типа от който съм избрал да ми е колекцията.

        // Има 2 типа Polymorphism, единия е Runtime(DynamicPolymorphism), но най-често се нарича просто Polymorphism (и до сега за него говорихме, по често срещан е! Питат ли ни за Polymorphism почти винаги ни питат за Runtime Polymorphism).
        //Другия вид Polymorphism е Compile time (Static Polymorphism), а това като същност си е overload на методи !!!
        //При overload на методи вече сме използвали Compile time Polymorphism.

        //За да оверрайднем метод, той трябва да е virtual в base класа или да е абстракт (от абстракт клас). Прайвет и статични методи не може да се оверрайдват.
        //Virtual members use base keyword to call the base class. Оверрайдванетo си върви надолу по веригата на наследяване, но ако искаме да го спрем можем със sealed!
        // При Compile time (Static Polymorphism) методите се overload - ват, а при Runtime(DynamicPolymorphism) се override -ват !!!

        //Скалиране е когато продрамата ти работи добре с 1000 потребители, но се налага да започне да работи с 3000, 20 000, 100 000 и това е много дълбока и обширна тема

        //Polymorphism - а работи абсолютно по същия начин и със интерфейси (не е само за наследяване)

        //Винаги гледаме как да не повтаряме код, това е закон!!!

        //Да не правим virtual конструктори, на лекцията за Solid ще разберем защо!

        //Ако един клас имплементира интерфейс, а друг го наследи, то той не трябва да имплементира интерфейса, автоматично го наследява и него.

        //кеyValuePair е клас който има само кеy и Value.
        //за да използваме добре полиморфизма трябва да използваме по базови интерфейси като IEnumerable - позволява ни да имаме повече колекции вътре (съдържа List, Dictionary, Stack, Queue). Да свикваме да използваме най-базовите класове/интерфейси за постигане на добър полиморфизъм.

        //Препоръчва мастер класа С# за мултитрейдинг, много на дълбоко се влиза за полиморфизма!

        //В ООП трябва да се стремим към възможно най - високо ниво на абстракция (Да прочетем за IEnumerable, ICollection, IComparable и да ги използваме - това ще ни даде по добър и четим код и лесно екстендване!

        //Има интерфейс IDictionary който ни дава Dictionary и SortedDictionary и спокойно надолу може да switch - ваме между двата

        //Factory Design pattern - демо във Vehicles !

        //По принципите на ООП е добре да има и abstract class и interface.

        //когато мислим за абстрактния клас трябва да мислим за всички функционалности общо, как би трябвало да се държат в общия случай, конкретиката ще се разписва надолу по наследниците!!! 

        //Design patterns са темплейти (шаблони) с които програмистите работят за да се постигне по-четим и лесен за поддръжка код. Factory Design pattern е такова нещо демо във Vehicles ! Идеята е че това е клас с метод отговорен за създаването на даден обект (клас Factory).

        //Прието е върху всеки един клас (който не е ентити клас, ще учим за ентити клас) да правим интерфейс дори да е съвсем прост и семпъл, така е съгласно един от СОЛИД принципите. 

        //ReSharper иска силна машина определено!!!

        //Ползата от интерфейсите ще разберем наистина, като разберем рефлекшъна!

        //Когато ЕксепшънМесиджа е глобален, т.е. ще се използва в повече от един клас се записва в Common папката в ExceptionMessages клас (public static string) и от там се подава където трябва. Когато е само за класа се записва горе като private const! 

        //Съвет: Четем си условието 2, 3 пъти, докато не добием в главата си реална картинка, т.е. целта на ООП е да пресъздаваме реални действия, пропъртита и бихейвиър на даден обект. След това да започнем да мислим обектно (имаме този обект, този. Тоя комуникира с тоя). Добра идея е да разписваме на един ноутпад (пейнт за визуализация) и като си измислим структурата, първо правим нея, после методи с бихейвиър, а Енджина накрая вече.

        //В абстракт класа имплементираме общите характеристики (неща) между всички наследници, а конкретиката я записваме с абстракт методи и пропъртита и така задължаваме наследниците да си ги имплементират според спецификите си!

        //Абстрактния клас който е наследник не трябва да имплементира друго освен конструктора на базовия клас (идето си знае ;-)).

        //По принцип структури данни и алгуритми след като завърщим може да намерим и в Ютуб видеа на Ники Костов (вместо платен курс). Важни са, но като минем Уеб и търсим или почнем работа!!! 

        //csharp design patterns for hummans като напиша излиза на сайта на GitHub, това е книга която трябва да прочета (с много хубави примери е!) ЗАДЪЛЖИТЕЛНО четиво за програмист преди интервю. 

        //ЗА ЕЗИЦИТЕ ЗА ПРОГРАМИРАНЕ набързо от Ники Костов:
        //С(си) няма ООП, С++ е С(си)  синтаксис +ООП.Те са по-бързи от С# защото са езици от по-ниско ниво и работят с инструйции близки до машинните инструкции и имаш повече контрол, но пишеш повече код. Който пише драйвери и операционна система ще ги напише на С, на С++ се пишат много игри поради бързината. С# е малко по-бавен за сметка на автоматичния мемори мениджмънт (при С и С++ няма такъв, наша отговорност е триенето на ненужни променливи и др., т.е. мемори мениджмънт-а), с командите от по-висок ред с по-малко код създаваме по-голяма програма. Но всеки език за да съществува той си има употреба: Всичко което виждаме в УЕБ е Java Script бутончета и визуални неща. Piton е език от високо ниво подходящ за работа със статистическа информация, машин лърнинг, по математически ориентирани програми. При него например с един ред правим диаграма (има си я вградена). Java e най-близък език до С#. PHP не е хубав език, защото в него има много глупости направени, той е език започнат за други цели, съвсем базов е бил и лека полека са го разширявали и той в момента е език за УЕБ, който е най-масовия, но това не го прави най-добрия за УЕБ. В училищата по информатика се учи С++, в състезанията по информатика и олимпиадите в света са на С++. За Ники Костов по подходящи за училищата са С#, Java или Piton за първи език. С# е майкрософт версията на Java

        }
    }
}
